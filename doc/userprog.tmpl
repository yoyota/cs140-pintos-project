             +--------------------------+
             |          CS 140          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

There were no new or changed structs, typedefs, or enumerations in the provided files. The main data structures used are:

* static char *argv[] (in parse_args): A static array of character pointers used to store the arguments parsed from the
    command-line string.
* char *argv_address[] (in argument_passing): A local array of character pointers that holds the stack addresses of the arguments
    to build the final argv array for the user process.


---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

1. Argument Parsing:
    In process.c, within the function responsible for loading the user program, I first create a copy of the command-line string.
To parse this string into arguments I iterate through the string, using spaces as delimiters, to
identify each argument token and store the pointers to these tokens in a temporary array.

2. Arranging `argv[]` in Order:
    The x86 stack grows from high memory addresses to low memory addresses. To set up the stack correctly for main(int argc, char 
*argv[]), I perform the following steps in reverse order:
    * First, I push the actual string content of each argument onto the stack, from last to first. I record the stack address
        where each string begins.
    * To ensure proper alignment for the pointers that follow, I push padding bytes (nulls) to make the current stack pointer
        word-aligned (a multiple of 4).
    * Next, I push a null pointer sentinel (argv[argc]).
    * Then, I push the addresses of the argument strings that I saved earlier, again from last to first. This creates the argv
        array on the stack, with argv[0] pointing to the first argument, argv[1] to the second, and so on.
    * Finally, I push the starting address of the argv array (which is the value for the argv parameter itself), the argument
        count (argc), and a fake return address (typically 0).

    By pushing the string data first and then the pointers in this right-to-left order, I ensure that when the program starts,
argv points to a correctly ordered array of pointers, and those pointers correctly reference the argument strings.

3. Avoiding Stack Page Overflow:
    Before writing anything to the user's stack, I perform a crucial safety check. I calculate the total size required for all
the argument strings, the argv pointers, the alignment padding, argc, and the fake return address. I then check if this total
calculated size is greater than the available stack size (PGSIZE, typically 4KB). If it is, it signifies that the arguments
cannot fit. In this case, I abort the process loading and have the exec system call return an error, preventing a kernel panic
from a page fault.


---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

Pintos uses strtok_r() because it is a reentrant, thread-safe function. The standard strtok() is not thread-safe because it uses
a static internal state to parse the string. In a multi-threaded environment like Pintos, using strtok() could lead to race
conditions if multiple threads try to parse strings simultaneously. strtok_r() avoids this by requiring the caller to manage the
state via a save pointer.

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

Two main advantages of the Unix approach are:

1. Flexibility: The shell can implement powerful features like I/O redirection (>), pipes (|), and wildcard expansion (*) before the
    program is executed. This keeps the kernel's interface simple and clean.
2. Simplicity: The kernel's responsibility is reduced. It only needs to create a process and provide it with an array of arguments,
    rather than needing to contain complex command-line parsing logic. This aligns with the Unix philosophy of small, focused tools.


                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
